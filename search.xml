<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[面试总结]]></title>
    <url>%2F2019%2F05%2F14%2Ftitle%2F</url>
    <content type="text"><![CDATA[重载（Overload）和重写（Override）的区别？方法的重载和重写都是实现多态的方式&gt;，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求，不能根据返回类型进行区分 接口和抽象类的区别1.抽象类和接口都不能实例化对象,但是可以定义抽象类和接口类型的引用.2.继承抽象类和实现接口都要对其中的抽象方法全部实现3.接口比抽象类更加抽象,抽象类中可以定义构造器,可以有抽象方法和具体方法.4.接口中方法全部都是抽象方法.5.抽象类中的成员可以是private,protected,public,接口全部都是public6.抽象类中可以定义成员变量,而接口中定义的成员变量实际上都是常量.7.有抽象方法的类必须声明为抽象类,而抽象类未必要有抽象方法. 什么是AQS?AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。AQS是抽象同步队列AbstractQueuedSynchronizer的简称,是实现同步机制的基础,并发包中的各种所谓的锁就是通过AQS实现的。 什么是CAS？CAS(Compare And Swap)，即比较并交换。是解决多线程并行情况下使用锁造成性能损耗的一种机制，CAS操作包含三个操作数——内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在CAS指令之前返回该位置的值。CAS有效地说明了“我认为位置V应该包含值A；如果包含该值，则将B放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。 IO,NIO,AIOio又叫bio，意思同步阻塞io，使用bio的时候，你需要不断的等待数据的到达，直到完成了这一次的io请求。对应于服务器的模式就是，客户端发起一次链接请求，那么服务器就产生一个线程来处理。nio 是同步非阻塞io，使用nio时，你不必一直等服务器的回应，你可以在发起服务器的io请求之后去做别的事情，但是需要不断的去轮询服务器来检查状态。aio 异步非阻塞io，一个有效请求使用一个线程来处理。处理对应的请求之前会先让os来进行处理，之后再调用对应的线程来处理。 Java 内存模型Java内存模型即Java Memory Model，简称JMM。JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。程序中的变量存储在主内存中，每个线程拥有自己的工作内存并存放变量的拷贝，线程读写自己的工作内存，通过主内存进行变量的交互。JMM就是规定了工作内存和主内存之间变量访问的细节，通过保障原子性、有序性、可见性来实现线程的有效协同和数据的安全。 说说JVM的垃圾回收策略JVM采用分代垃圾回收。在JVM的内存空间中把堆空间分为年老代和年轻代。将大量创建了没多久就会消亡的对象存储在年轻代，而年老代中存放生命周期长久的实例对象。 对象存活检查(可达性分析算法，引用计数法)1、引用计数算法给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。但是，JVM里面并没有选用引用计数算法来管理内存，主要原因是它很难解决对象之间相互循环引用的问题。2、可达性分析算法通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。 进程同步如进程、线程同步，可理解为进程或线程A和B一块配合，A执行到一定程度时要依靠B的某个结果，于是停下来，示意B运行；B依言执行，再将结果给A；A再继续操作。所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回，同时其它线程也不能调用这个方法。按照这个定义，其实绝大多数函数都是同步调用（例如sin, isdigit等）。但是一般而言，我们在说同步、异步的时候，特指那些需要其他部件协作或者需要一定时间完成的任务。例如Window API函数SendMessage。该函数发送一个消息给某个窗口，在对方处理完消息之前，这个函数不返回。当对方处理完毕以后，该函数才把消息处理函数所返回的LRESULT值返回给调用者。在多线程编程里面，一些敏感数据不允许被多个线程同时访问，此时就使用同步访问技术，保证数据在任何时刻，最多有一个线程访问，以保证数据的完整性。 什么是UMLUML是统一建模语言（UML是 Unified Modeling Language的缩写）是用来对软件密集系统进行可视化建模的一种语言。UML为面向对象开发系统的产品进行说明、可视化、和编制文档的一种标准语言。统一建模语言 (UML)是非专利的第三代建模和规约语言。 UML是在开发阶段，说明，可视化，构建和书写一个面向对象软件密集系统的制品的开放方法。UML展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面,特别是在软件架构层次已经被验证有效。UML可以贯穿软件开发周期中的每一个阶段。被OMG采纳作为业界的标准。UML最适于数据建模，业务建模，对象建模，组件建模。UML作为一种模型语言，它使开发人员专注于建立产品的模型和结构，而不是选用什么程序语言和算法实现。当模型建立之后，模型可以被UML工具转化成指定的程序语言代码。IBM的Rational Rose和MS的Visio都是UML工具。 什么是ACID事务的四个基本特征：Atomic（原子性）：事务中包含的操作被看做一个逻辑单元，这个逻辑单元中的操作要么全部成 功，要么全部失败。Consistency（一致性）：事务完成时，数据必须处于一致状态，数据的完整性约束没有被破坏，事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。Isolation（隔离性）：事务允许多个用户对同一个数据进行并发访问，而不破坏数据的正确性 和完整性。同时，并行事务的修改必须与其他并行事务的修改相互独立。Durability（持久性）：事务结束后，事务处理的结果必须能够得到固化。 Java内存区域划分大多数 JVM 将内存区域划分为 Method Area（Non-Heap）（方法区） ,Heap（堆） , Program Counter Register（程序计数器） , VM Stack（虚拟机栈，也有翻译成JAVA 方法栈的）,Native Method Stack （ 本地方法栈 ），其中Method Area 和 Heap 是线程共享的 ，VM Stack，Native Method Stack 和Program Counter Register 是非线程共享的。为什么分为 线程共享和非线程共享的呢?请继续往下看。首先我们熟悉一下一个一般性的 Java 程序的工作过程。一个 Java 源程序文件，会被编译为字节码文件（以 class 为扩展名），每个java程序都需要运行在自己的JVM上，然后告知 JVM 程序的运行入口，再被 JVM 通过字节码解释器加载运行。那么程序开始运行后，都是如何涉及到各内存区域的呢？概括地说来，JVM初始运行的时候都会分配好 Method Area（方法区） 和Heap（堆） ，而JVM 每遇到一个线程，就为其分配一个 Program Counter Register（程序计数器） , VM Stack（虚拟机栈）和Native Method Stack （本地方法栈）， 当线程终止时，三者（虚拟机栈，本地方法栈和程序计数器）所占用的内存空间也会被释放掉。这也是为什么我把内存区域分为线程共享和非线程共享的原因，非线程共享的那三个区域的生命周期与所属线程相同，而线程共享的区域与JAVA程序运行的生命周期相同，所以这也是系统垃圾回收的场所只发生在线程共享的区域（实际上对大部分虚拟机来说知发生在Heap上）的原因。 Spring事务传播特性PROPAGATION_REQUIRED–支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。PROPAGATION_SUPPORTS–支持当前事务，如果当前没有事务，就以非事务方式执行。PROPAGATION_MANDATORY–支持当前事务，如果当前没有事务，就抛出异常。PROPAGATION_REQUIRES_NEW–新建事务，如果当前存在事务，把当前事务挂起。PROPAGATION_NOT_SUPPORTED–以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。PROPAGATION_NEVER–以非事务方式执行，如果当前存在事务，则抛出异常。 Servlet的生命周期Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。(1)加载：容器通过类加载器使用servlet类对应的文件加载servlet(2)创建：通过调用servlet构造函数创建一个servlet对象(3)初始化：调用init方法初始化(4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求(5)卸载：调用destroy方法让servlet自己释放其占用的资源 init方法： 是在servlet实例创建时调用的方法，用于创建或打开任何与servlet相的资源和初始 化servlet的状态，Servlet规范保证调用init方法前不会处理任何请求 service方法：是servlet真正处理客户端传过来的请求的方法，由web容器调用， 根据HTTP请求方法（GET、POST等），将请求分发到doGet、doPost等方法destory方法：是在servlet实例被销毁时由web容器调用。Servlet规范确保在destroy方法调用之 前所有请求的处理均完成，需要覆盖destroy方法的情况：释放任何在init方法中 打开的与servlet相关的资源存储servlet的状态 加载驱动的方法1.Class.forName(“com.microsoft.sqlserver.jdbc.SQLServerDriver”); DriverManager.registerDriver(new com.mysql.jdbc.Driver());3.System.setProperty(“jdbc.drivers”, “com.mysql.jdbc.Driver”);JVM内存配置参数-Xmx：最大堆大小-Xms：初始堆大小-Xmn:年轻代大小-XXSurvivorRatio：年轻代中Eden区与Survivor区的大小比值二叉树遍历前序：根左右中序：左根右后序：左右根B+、B-树二叉搜索树：1.所有非叶子结点至多拥有两个儿子（Left和Right）；2.所有结点存储一个关键字；3.非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；二叉搜索树的搜索，从根结点开始，如果查询的关键字与结点的关键字相等，那么就命中；否则，如果查询关键字比结点关键字小，就进入左儿子；如果比结点关键字大，就进入右儿子；如果左儿子或右儿子的指针为空，则报告找不到相应的关键字。B-树：是一种多路搜索树（并不是二叉的）：1.定义任意非叶子结点最多只有M个儿子；且M&gt;2；2.根结点的儿子数为[2, M]；3.除根结点以外的非叶子结点的儿子数为[M/2, M]；4.每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）5.非叶子结点的关键字个数=指向儿子的指针个数-1；6.非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；7.非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；8.所有叶子结点位于同一层；B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；B+树：B+树是B-树的变体，也是一种多路搜索树：1.其定义基本与B-树同，除了：2.非叶子结点的子树指针与关键字个数相同；3.非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；5.为所有叶子结点增加一个链指针；6.所有关键字都在叶子结点出现；B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找。哈夫曼树哈夫曼树，又称最优树，是一类带权路径长度最短的树。从树中一个结点到另一个结点之间的分支构成两个结点的路径，路径上的分支数目叫做路径长度。树的路径长度是从树根到每一个结点的路径长度之和。结点的带权路径长度为从该结点到树根之间的路径长度与结点上权的乘积。树的带权路径长度为树中所有叶子结点的带权路径长度之和，通常记作WPL。创建哈夫曼树：假设有n个结点，n个结点的权值分别为w1,w2,…,wn，构成的二叉树的集合为F={T1,T2,…,Tn}，则可构造一棵含有n个叶子结点的哈夫曼树。步骤如下：（1）从F中选取两棵根结点权值最小的树作为左右子树构造一棵新的二叉树，其新的二叉树的权值为其左右子树根结点权值之和；（2）从F中删除上一步选取的两棵二叉树，将新构造的树放到F中；（3）重复（1）（2），直到F只含一棵树为止。冒泡、插入、选择、希尔排序冒泡排序基本的逻辑是，取第一个元素与后一个比较，如果大于后者，就与后者互换位置，不大于，就保持位置不变。再拿第二个元素与后者比较，如果大于后者，就与后者互换位置。一轮比较之后，最大的元素就移动到末尾。相当于最大的就冒出来了。再进行第二轮，第三轮，直到排序完毕。平均情况时间复杂度为O(n^2)。public int[] bubbleSort(int[] a) {int n = a.length; if (n &lt;= 1) { return a; } for (int i = 1; i &lt; n; i++) { boolean flag = false; // 开关，当某次内层循环，没有数据交换时，已排好顺序，直接跳出循环。 for (int j = 0; j &lt; n - i; j++) { if (a[j] &gt; a[j + 1]) { int temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; flag = true; } } if (!flag) { break; } } return a; }插入排序基本逻辑是，把元素分为已排序的和未排序的。每次从未排序的元素取出第一个，与已排序的元素从尾到头逐一比较，找到插入点，将之后的元素都往后移一位，腾出位置给该元素。平均情况时间复杂度是O(n^2)。public int[] insertSort(int[] a) {int n = a.length; if (n &lt;= 1) { return a; } for (int i = 1; i &lt; n; i++) { int temp = a[i]; int j = i - 1; for (; j &gt;= 0; j--) { if (a[j] &gt; temp) { a[j + 1] = a[j]; // 比temp 大的已排序数据后移一位 } else { break; } } a[j + 1] = temp; // 空出来的位置，把temp放进去 } return a; }选择排序基本逻辑是：把所有数据分为已排序区间和未排序区间。每次从未排序区间中，选出最小值，之后将该值与未排序区间第一个元素互换位置，此时已排序区间元素个数多了一个，未排序区间内的元素少了一个。如此循环直到未排序区间没有元素为止。平均情况时间复杂度是O(n^2)。public int[] selectionSort(int[] a) {int n = a.length; if (n &lt;= 1) { return a; } for (int i =1; i &lt; n; i++) { int j = i-1; int min = a[j]; // 最小的数值 int index = j; // 最小值对应的下标 for (; j &lt; n-1 ; j++) { if (min &gt; a[j+1]) { min = a[j+1]; index = j+1; } } //最小值a[index]与放未排序的首位a[i-1]互换位置 if (index != i-1) { int temp = a[i-1]; a[i-1] = a [index]; a [index] = temp; } } return a; }希尔排序先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。时间复杂度是O(n^2)。 /*希尔排序的原理:根据需求，如果你想要结果从大到小排列，它会首先将数组进行分组，然后将较大值移到前面，较小值移到后面，最后将整个数组进行插入排序，这样比起一开始就用插入排序减少了数据交换和移动的次数，可以说希尔排序是加强版的插入排序拿数组5, 2, 8, 9, 1, 3，4来说，数组长度为7，当increment为3时，数组分为两个序列5，2，8和9，1，3，4，第一次排序，9和5比较，1和2比较，3和8比较，4和比其下标值小increment的数组值相比较此例子是按照从大到小排列，所以大的会排在前面，第一次排序后数组为9, 2, 8, 5, 1, 3，4第一次后increment的值变为3/2=1,此时对数组进行插入排序，实现数组从大到小排 / public static void shellSort(int[] data) { int j = 0; int temp = 0; //每次将步长缩短为原来的一半 for (int increment = data.length / 2; increment &gt; 0; increment /= 2) { for (int i = increment; i &lt; data.length; i++) { temp = data[i]; for (j = i; j &gt;= increment; j -= increment) { if(temp &gt; data[j - increment])//如想从小到大排只需修改这里 { data[j] = data[j - increment]; } else { break; } } data[j] = temp; } } } 归并、快速、堆排序归并排序如果要排序一个数组，我们先把数组从中间分成前后两个部分，然后对前后两个部分分别排序，再将两个部分合并在一直，这个整个数组就是一个有序的数组了。平均情况时间复杂度是O(nlogn)。 public static int[] sort(int[] nums, int low, int high) { int mid = (low + high) / 2; if (low &lt; high) { // 左边 sort(nums, low, mid); // 右边 sort(nums, mid + 1, high); // 左右归并 merge(nums, low, mid, high); } return nums; } /** * 将数组中low到high位置的数进行排序 * @param nums 待排序数组 * @param low 待排的开始位置 * @param mid 待排中间位置 * @param high 待排结束位置 */ public static void merge(int[] nums, int low, int mid, int high) { int[] temp = new int[high - low + 1]; int i = low;// 左指针 int j = mid + 1;// 右指针 int k = 0; // 把较小的数先移到新数组中 while (i &lt;= mid &amp;&amp; j &lt;= high) { if (nums[i] &lt; nums[j]) { temp[k++] = nums[i++]; } else { temp[k++] = nums[j++]; } } // 把左边剩余的数移入数组 while (i &lt;= mid) { temp[k++] = nums[i++]; } // 把右边边剩余的数移入数组 while (j &lt;= high) { temp[k++] = nums[j++]; } // 把新数组中的数覆盖nums数组 for (int k2 = 0; k2 &lt; temp.length; k2++) { nums[k2 + low] = temp[k2]; } } 快速排序快速排序（Quicksort）算法也是利用分治思想，有点像归并排序，但思路不一样。待会我们再讲两者的区别。它的思想是这样的：如果要排序的数组中下标从p到r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为pivot(分区点)。我们遍历 p 到 r 之间的数据，将小于 pivot 的放在左边，将大于 pivot 的放到右边，将pivot放到中间。经过这一步骤，数组 p 到 r 之间数据被分成了三个部分，前面 p 到 q-1 之间的都是小于pivot的，中间是pivot,后面的 q+1到 r 之间的是大于pivot的。 我们用递归排序下标从p 到 q-1 之间的数据和下标从q+1到 r 之间的数据，直到分区缩小为1，这时所有的数据就都有序了。平均情况时间复杂度是O(nlogn)。 堆排序堆是一种特殊的树形数据结构，其每个节点都有一个值，通常提到的堆都是指一颗完全二叉树，根结点的值小于（或大于）两个子节点的值，同时，根节点的两个子树也分别是一个堆。 堆排序就是利用堆（假设利用大顶堆）进行排序的方法。它的基本思想是，将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根节点。将它移走（其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），然后将剩余的 n-1 个序列重新构造成一个堆，这样就会得到 n 个元素中次大的值。如此反复执行，便能得到一个有序序列了。 三次握手四次分手 三次握手第一次握手：主机A发送位码为syn＝1,随机产生seq number=x的数据包到服务器，客户端进入SYN_SEND状态，等待服务器的确认；主机B由SYN=1知道，A要求建立联机；第二次握手：主机B收到请求后要确认联机信息，向A发送ack number(主机A的seq+1),syn=1,ack=1,随机产生seq=y的包,此时服务器进入SYN_RECV状态;第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，主机A会再发送ack number(主机B的seq+1),ack=1，主机B收到后确认seq值与ack=1则连接建立成功。客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。 四次挥手第一次挥手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；第二次挥手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我也没有数据要发送了，可以进行关闭连接了；第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入CLOSE_WAIT状态；第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。 线程安全线程也是有从产生到死亡的过程，其中包含了“创建”、“就绪”、“运行”、“阻塞”、“死亡”，这5个步骤。 新建状态: 使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。 就绪状态: 当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。 运行状态: 如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就 绪状态和死亡状态。 阻塞状态: 如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或 获得设备资源后可以重新进入就绪状态。可以分为三种： 等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。 同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。 其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。 死亡状态:一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。 简单记忆线程安全的集合类： 喂！SHE！ 喂是指 vector，S是指 stack， H是指 hashtable，E是指：Eenumeration。 JSP四大作用域page (作用范围最小)：存储在pageContext对象中的属性仅可以被当前JSP页面的当前响应过程中调用的各个组件访问，例如，正在响应当前请求的JSP页面和它调用的各个自定义标签类。request：存储在request对象中的属性可以被属于同一个请求的所有Servlet和JSP页面访问（在有转发的情况下可以跨页面获取属性值），例如使用PageContext.forward和PageContext.include方法连接起来的多个Servlet和JSP页面。session：存储在session对象中的属性可以被属于同一个会话（浏览器打开直到关闭称为一次会话，且在此期间会话不失效）的所有Servlet和JSP页面访问。application（作用范围最大）：存储在application对象中的属性可以被同一个WEB应用程序中的所有Servlet和JSP页面访问。（属性作用范围最大）。 Spring的AOP理解AOP，一般称为面向方面（切面）编程，作为面向对象的一种补充，用于解剖封装好的对象内部，找出其中对多个对象产生影响的公共行为，并将其封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），切面将那些与业务无关，却被业务模块共同调用的逻辑提取并封装起来，减少了系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理。AOP实现的关键在于AOP框架自动创建的AOP代理，AOP代理主要分为静态代理和动态代理。静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。（1）AspectJ是静态代理的增强，所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，他会在编译阶段将AspectJ织入到Java字节码中，运行的时候就是增强之后的AOP对象。（2）Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理：①JDK动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是InvocationHandler接口和Proxy类。生成的代理对象的方法调用都会委托到InvocationHandler.invoke()方法，当我们调用代理类对象的方法时，这个“调用”会转送到invoke方法中，代理类对象作为proxy参数传入，参数method标识了我们具体调用的是代理类的哪个方法，args为这个方法的参数。②如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法，覆盖方法时可以添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。（3）静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。 Spring的IoC理解（1）IOC就是控制反转。就是对象的创建权反转交给Spring，由容器控制程序之间的依赖关系，作用是实现了程序的解耦合，而非传统实现中，由程序代码直接操控。(依赖)控制权由应用代码本身转到了外部容器，由容器根据配置文件去创建实例并管理各个实例之间的依赖关系，控制权的转移，是所谓反转，并且由容器动态的将某种依赖关系注入到组件之中。BeanFactory 是Spring IoC容器的具体实现与核心接口，提供了一个先进的配置机制，使得任何类型的对象的配置成为可能，用来包装和管理各种bean。（2）最直观的表达就是，IOC让对象的创建不用去new了，可以由spring自动生产，这里用的就是java的反射机制，通过反射在运行时动态的去创建、调用对象。spring就是根据配置文件在运行时动态的去创建对象，并调用对象的方法的。（3）Spring的IOC有三种注入方式 ：第一是根据属性注入，也叫set方法注入；第二种是根据构造方法进行注入；第三种是根据注解进行注入。（4）IoC，控制反转：将对象交给容器管理，你只需要在spring配置文件总配置相应的bean，以及设置相关的属性，让spring容器生成类的实例对象以及管理对象。在spring容器启动的时候，spring会把你在配置文件中配置的bean都初始化以及装配好，然后在你需要调用的时候，就把它已经初始化好的那些bean分配给你需要调用这些bean的类。就是将对象的控制权反转给spring容器管理。（5）DI机制（Dependency Injection，依赖注入）：可以说是IoC的其中一个内容，在容器实例化对象的时候主动的将被调用者（或者说它的依赖对象）注入给调用对象。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。 IoC让相互协作的组件保持松散的耦合，而AOP编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。 BeanFactory和ApplicationContext的区别BeanFactory和ApplicationContext是Spring的两大核心接口，而其中ApplicationContext是BeanFactory的子接口。它们都可以当做Spring的容器，生成Bean实例的，并管理容器中的Bean。 （1）BeanFactory：是Spring里面最底层的接口，提供了最简单的容器的功能，负责读取bean配置文档，管理bean的加载与实例化，维护bean之间的依赖关系，负责bean的生命周期，但是无法支持spring的aop功能和web应用。（2）ApplicationContext接口作为BeanFactory的派生，因而具有BeanFactory所有的功能。而且ApplicationContext还在功能上做了扩展，以一种更面向框架的方式工作以及对上下文进行分层和实现继承，相较于BeanFactorty，ApplicationContext还提供了以下的功能：①默认初始化所有的Singleton，也可以通过配置取消预初始化。②继承MessageSource，因此支持国际化。③资源访问，比如访问URL和文件。④事件机制。⑤同时加载多个配置文件。⑥以声明式方式启动并创建Spring容器。⑦载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。（3）①BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化，这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。②而ApplicationContext则相反，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean,确保当你需要的时候，你就不用等待，因为它们已经创建好了。③相对于基本的BeanFactory，ApplicationContext唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。（4）BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。（5）BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。 解释Spring支持的几种bean的作用域Spring容器中的bean可以分为5个范围：（1）singleton：这种bean范围是默认的，这种范围确保不管接受到多少个请求，每个容器中只有一个bean的实例，单例的模式由beanfactory自身来维护。（2）prototype：原形范围与单例范围相反，为每一个bean请求提供一个实例。（3）request：在请求bean范围内会每一个来自客户端的网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。（4）Session：与请求范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。（5）global-session：global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。全局作用域与Servlet中的session作用域效果相同。 SpringMVC与Struts2的主要区别①springmvc的入口是一个servlet即前端控制器，而struts2入口是一个filter过虑器。②springmvc是基于方法开发，传递参数是通过方法形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。③Struts采用值栈存储请求和响应的数据，通过OGNL存取数据， springmvc通过参数解析器是将request对象内容进行解析成方法形参，将响应数据和页面封装成ModelAndView对象，最后又将模型数据通过request对象传输到页面。 Jsp视图解析器默认使用jstl。 ArrayList和Vector的区别共同点： &emsp;这两个类都实现了List接口，它们都是有序的集合(存储有序)，底层是数组。我们可以按位置索引号取出某个元素，允许元素重复和为null。区别： &emsp;同步性： &emsp;&emsp;ArrayList是非同步的 &emsp;&emsp;Vector是同步的 &emsp;&emsp;即便需要同步的时候，我们可以使用Collections工具类来构建出同步的ArrayList而不用Vector &emsp;扩容大小： &emsp;&emsp;Vector增长原来的一倍，ArrayList增长原来的0.5倍 HashMap和Hashtable的区别共同点： &emsp;从存储结构和实现来讲基本上都是相同的，都是实现Map接口~区别： &emsp;同步性： &emsp;&emsp;HashMap是非同步的 &emsp;&emsp;Hashtable是同步的 &emsp;&emsp;需要同步的时候，我们往往不使用，而使用ConcurrentHashMap &emsp;是否允许为null： &emsp;&emsp;HashMap允许为null &emsp;&emsp;Hashtable不允许为null &emsp;继承不同： &emsp;&emsp;HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; &emsp;&emsp;public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt; List和Map的区别共同点：&emsp;都是Java常用的容器，都是接口不同点：&emsp;存储结构不同：&emsp;&emsp;List是存储单列的集合&emsp;&emsp;Map存储的是key-value键值对的集合&emsp;元素是否可重复：&emsp;&emsp;List允许元素重复&emsp;&emsp;Map不允许key重复&emsp;是否有序：&emsp;&emsp;List集合是有序的(存储有序)&emsp;&emsp;Map集合是无序的(存储无序) Collection和Collections的区别Collection是集合的上级接口，继承它的有Set和List接口Collections是集合的工具类，提供了一系列的静态方法对集合的搜索、查找、同步等操作 说出ArrayList,LinkedList的存储性能和特性ArrayList的底层是数组，LinkedList的底层是双向链表。ArrayList它支持以角标位置进行索引出对应的元素(随机访问)，而LinkedList则需要遍历整个链表来获取对应的元素。因此一般来说ArrayList的访问速度是要比LinkedList要快的ArrayList由于是数组，对于删除和修改而言消耗是比较大(复制和移动数组实现)，LinkedList是双向链表删除和修改只需要修改对应的指针即可，消耗是很小的。因此一般来说LinkedList的增删速度是要比ArrayList要快的 JDBC操作数据库的步骤1.注册数据库驱动。2.建立数据库连接。3.创建一个Statement。4.执行SQL语句。5.处理结果集。6.关闭数据库连接 Connection connection = null; Statement statement = null; ResultSet resultSet = null; try { /* * 加载驱动有两种方式 * * 1：会导致驱动会注册两次，过度依赖于mysql的api，脱离的mysql的开发包，程序则无法编译 * 2：驱动只会加载一次，不需要依赖具体的驱动，灵活性高 * 我们一般都是使用第二种方式 * */ //1. //DriverManager.registerDriver(new com.mysql.jdbc.Driver()); //2. Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //获取与数据库连接的对象-Connetcion connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/text&quot;, &quot;root&quot;, &quot;root&quot;); //获取执行sql语句的statement对象 statement = connection.createStatement(); //执行sql语句,拿到结果集 resultSet = statement.executeQuery(&quot;SELECT * FROM users&quot;); //遍历结果集，得到数据 while (resultSet.next()) { System.out.println(resultSet.getString(1)); System.out.println(resultSet.getString(2)); } } catch (SQLException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } finally { /* * 关闭资源，后调用的先关闭 * 关闭之前，要判断对象是否存在 * */ if (resultSet != null) { try { resultSet.close(); } catch (SQLException e) { e.printStackTrace(); } } if (statement != null) { try { statement.close(); } catch (SQLException e) { e.printStackTrace(); } } if (connection != null) { try { connection.close(); } catch (SQLException e) { e.printStackTrace(); } } } 一次完整的HTTP请求所经历的7个步骤HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：&nbsp;&nbsp;建立TCP连接-&gt;发送请求行-&gt;发送请求头-&gt;（到达服务器）发送状态行-&gt;发送响应头-&gt;发送响应数据-&gt;断TCP连接1.建立TCP连接在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建 Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则， 只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。2.Web浏览器向Web服务器发送请求行一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET /sample/hello.jsp HTTP/1.1。3.Web浏览器发送请求头浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。4.Web服务器应答客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。5.Web服务器发送应答头正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。6.Web服务器向浏览器发送数据Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。7.Web服务器关闭TCP连接一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：Connection:keep-aliveTCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>垃圾回收机制</tag>
        <tag>进程问题</tag>
      </tags>
  </entry>
</search>
